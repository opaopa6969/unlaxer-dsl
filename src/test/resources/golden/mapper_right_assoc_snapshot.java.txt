package org.example.snapshot;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.unlaxer.Parsed;
import org.unlaxer.StringSource;
import org.unlaxer.Token;
import org.unlaxer.context.ParseContext;
import org.unlaxer.parser.Parser;

/**
 * SnapshotRightAssoc parse tree (Token) -> SnapshotRightAssocAST mapper.
 */
public class SnapshotRightAssocMapper {

    private SnapshotRightAssocMapper() {}

    // =========================================================================
    // Entry Point
    // =========================================================================

    public static SnapshotRightAssocAST.PowNode parse(String source) {
        // TODO: implement after SnapshotRightAssocParsers is generated
        // StringSource stringSource = StringSource.createRootSource(source);
        // try (ParseContext context = new ParseContext(stringSource)) {
        //     Parser rootParser = SnapshotRightAssocParsers.getRootParser();
        //     Parsed parsed = rootParser.parse(context);
        //     if (!parsed.isSucceeded()) {
        //         throw new IllegalArgumentException("Parse failed: " + source);
        //     }
        //     return toPowNode(parsed.getRootToken());
        // }
        throw new UnsupportedOperationException("SnapshotRightAssocParsers: not implemented");
    }

    // =========================================================================
    // Mapping Methods
    // =========================================================================

    static SnapshotRightAssocAST.PowNode toPowNode(Token token) {
        // TODO: extract left seed node from token
        // TODO: extract repeated operators and right operands from token
        SnapshotRightAssocAST.PowNode left = null;
        List<String> ops = List.of();
        List<SnapshotRightAssocAST.PowNode> rights = List.of();
        return foldRightAssocPowNode(left, ops, rights);
    }

    static SnapshotRightAssocAST.PowNode foldRightAssocPowNode(
        SnapshotRightAssocAST.PowNode left,
        List<String> ops,
        List<SnapshotRightAssocAST.PowNode> rights
    ) {
        if (left == null) return null;
        if (ops.size() != rights.size()) {
            throw new IllegalArgumentException("ops/rights length mismatch");
        }
        if (ops.isEmpty()) return left;
        SnapshotRightAssocAST.PowNode current = rights.get(ops.size() - 1);
        for (int i = ops.size() - 2; i >= 0; i--) {
            current = new SnapshotRightAssocAST.PowNode(rights.get(i), ops.get(i + 1), current);
        }
        return new SnapshotRightAssocAST.PowNode(left, ops.get(0), current);
    }

    // =========================================================================
    // Utilities
    // =========================================================================

    static List<Token> findDescendants(Token token, Class<? extends Parser> parserClass) {
        List<Token> results = new ArrayList<>();
        for (Token child : token.filteredChildren) {
            if (child.parser.getClass() == parserClass) {
                results.add(child);
            } else {
                results.addAll(findDescendants(child, parserClass));
            }
        }
        return results;
    }

    static String stripQuotes(String quoted) {
        if (quoted.length() >= 2
            && '\'' == quoted.charAt(0)
            && '\'' == quoted.charAt(quoted.length() - 1)) {
            return quoted.substring(1, quoted.length() - 1);
        }
        return quoted;
    }
}
